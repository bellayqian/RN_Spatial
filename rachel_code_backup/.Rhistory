# Load required package
library(sp)
library(sf)
library(tidyverse)
library(ggplot2)
# Define the resolution of the first grid (coarser resolution)
resolution1 <- c(5, 5)  # 5x5 grid
# Define the resolution of the second grid (finer resolution)
resolution2 <- c(10, 10)  # 10x10 grid
# Create the first spatial grid (coarser grid)
grid1 <- GridTopology(cellcentre.offset = c(0.5, 0.5),
cellsize = c(2, 2),  # Cell size adjusted to match extent and resolution
cells.dim = resolution1)
sp_grid1 <- SpatialGrid(grid1)
# Create the second spatial grid (finer grid)
grid2 <- GridTopology(cellcentre.offset = c(0, 0),
cellsize = c(1, 1),  # Smaller cell size for finer resolution
cells.dim = resolution2)
sp_grid2 <- SpatialGrid(grid2)
# Plot both grids to visualize the differences
plot(sp_grid2, col = "lightblue", main = "Spatial Grids with Different Resolutions")
plot(sp_grid1, col = 'red', add = TRUE)  # Second grid with finer resolution shown in red border
## now union together cells of the finer grid to create non-nested misalignment (there's probably a simpler/cleaner way to do this)
sp_grid2_poly<-st_as_sf(as(sp_grid2,'SpatialPolygons'))
sp_grid1_poly<-st_as_sf(as(sp_grid1,'SpatialPolygons'))
## add ids and plot to check ordering of grid cells in the dataset
## add cell ids
# sp_grid2_poly$ID<-1:nrow(sp_grid2_poly)
# ggplot() +
#   geom_sf(data = sp_grid2_poly, aes(fill = ID))
## pick cells to cross-union (cell to union that cross boundaries of coarser grid)
## 2,3 or 4,5 or 6,7 or 8,9
## pick one of these every other row
set.seed(1)
pair_list<-list(c(2,3),c(4,5),c(6,7),c(8,9))
union_ids<-matrix(0,10,10)
id_num<-1
for (i in seq(1,10,2)){
union_ids[i,pair_list[[sample(1:4,size=1)]]]<-id_num
id_num<-id_num+1
}
sp_grid2_poly$union_ids<-c(t(union_ids))
store_xunions<-NULL
for (i in 1:max(sp_grid2_poly$union_ids)){
temp<-sp_grid2_poly[sp_grid2_poly$union_ids==i, ] %>%
st_union() %>% # unite to a single geometry object
st_sf() # make the geometry a data frame object
store_xunions<-rbind(store_xunions,temp)
}
## now merge together remaining cells of finer grid to get as close as possible to grid 1
grid2_nounion<-subset(sp_grid2_poly,union_ids==0)
## find cells that intersect with each cell of grid 1 and union them
store_iunions<-NULL
for (i in 1:nrow(sp_grid1_poly)){
temp<-grid2_nounion[c(st_contains(sp_grid1_poly[i,],grid2_nounion,sparse=F))==T,] %>%
st_union() %>% # unite to a single geometry object
st_sf() # make the geometry a data frame object
store_iunions<-rbind(store_iunions,temp)
}
grid2_final<-rbind(store_iunions,store_xunions)
plot(st_geometry(grid2_final),border='red')
plot(st_geometry(sp_grid1_poly),add=T)
## rename and save grids
gridx<-grid2_final
gridy<-sp_grid1_poly
save(gridx,gridy,
file='sim_grids.RData')
rm(list=ls())
library(sp)
library(spdep)
library(sf)
library(MASS)
library(raster)
library(tidyverse)
library(nimble)
## read in the misaligned grids
load('sim_grids.RData')
gridy$ID<-1:nrow(gridy)
gridx$ID<-1:nrow(gridx)
## for now i'll just simulate y (on y grid), x (on x grid), and one predictor (on atoms) randomly from spatial processes
## later will need to use more sophisticated DGP
## helper function for generating spatial data
gen_spat<-function(W,rho=.6,var_spat=1,global_int=3){
# Precision matrix for CAR model
precision_matrix <- diag(colSums(W)) - rho * W
# Generate spatial effects
spatial_effects <- mvrnorm(1, mu = rep(0, nrow(W)), Sigma = solve(precision_matrix) * var_spat)
# Add observation noise
observed_values <- rpois(nrow(W), lambda=exp(global_int+spatial_effects))
return(observed_values)
}
################
## generate Y ##
################
S_y<-nrow(gridy)
# Create Y grid neighbor list using Queen's case
neighbors_y <- poly2nb(as(gridy, "Spatial"), queen = TRUE)
# Convert neighbor list to adjacency matrix
W_y <- nb2mat(neighbors_y, style = "B", zero.policy = TRUE)
## generate Y
gridy$y<-gen_spat(W=W_y)
################
## generate X ##
################
S_x<-nrow(gridx)
# Create Y grid neighbor list using Queen's case
neighbors_x <- poly2nb(as(gridx, "Spatial"), queen = TRUE)
# Convert neighbor list to adjacency matrix
W_x <- nb2mat(neighbors_x, style = "B", zero.policy = TRUE)
## generate Y
gridx$x<-gen_spat(W=W_x)
###################################
## generate atom-level predictor ##
###################################
## get atoms
atoms<-st_as_sf(raster::intersect(as(gridy,'Spatial'),as(gridx,'Spatial')))
plot(st_geometry(atoms))
names(atoms)[which(names(atoms)=='ID')]<-c("ID_y")
names(atoms)[which(names(atoms)=='ID.1')]<-c("ID_x")
atoms$ID_atomorder<-1:nrow(atoms)
## now generate a predictor over the atoms
# Create atom neighbor list using Queen's case
neighbors_pred <- poly2nb(as(atoms, "Spatial"), queen = TRUE)
# Convert neighbor list to adjacency matrix
W_pred <- nb2mat(neighbors_pred, style = "B", zero.policy = TRUE)
## generate pred
pred<-gen_spat(W=W_pred)
## save simulated data
save(gridy,gridx,atoms,pred,file='sim_data.RData')
rm(list=ls())
library(sp)
library(spdep)
library(sf)
library(MASS)
library(raster)
library(tidyverse)
library(nimble)
## load in simulated data
load('sim_data.RData')
S_x<-nrow(gridx)
S_y<-nrow(gridy)
#####################
## prep for nimble ##
#####################
## get the spatial bookkeeping items ##
## x grids that aren't atoms
x_nonatoms<-atoms$ID_x[which(duplicated(atoms$ID_x)==T)]
x_nonatoms<-x_nonatoms[order(x_nonatoms)]
J_x<-nrow(gridx)-length(x_nonatoms)
## y grids that aren't atoms
y_nonatoms<-atoms$ID_y[which(duplicated(atoms$ID_y)==T)]
y_nonatoms<-y_nonatoms[order(y_nonatoms)]
J_y<-nrow(gridy)-length(y_nonatoms)
## re-order x and y so that first J_x/J_y units are atom-equivalents
gridy_yorder<-gridy[c(gridy$ID[-y_nonatoms],y_nonatoms),]
names(gridy_yorder)[which(names(gridy_yorder)=='ID')]<-'ID_y'
gridy_yorder$ID_yorder<-1:nrow(gridy_yorder)
gridx_xorder<-gridx[c(gridx$ID[-x_nonatoms],x_nonatoms),]
names(gridx_xorder)[which(names(gridx_xorder)=='ID')]<-'ID_x'
gridx_xorder$ID_xorder<-1:nrow(gridx_xorder)
## link the new IDs into the atoms dataset so we can find correspondence between new Y grid ids and atoms
IDxwalk<-merge(st_drop_geometry(atoms),st_drop_geometry(gridy_yorder),by='ID_y')
IDxwalk<-merge(IDxwalk,st_drop_geometry(gridx_xorder),by='ID_x')
## get x/y_to_atom
x_to_atom<-IDxwalk$ID_atomorder[order(IDxwalk$ID_xorder,IDxwalk$ID_atomorder)]
y_to_atom<-IDxwalk$ID_atomorder[order(IDxwalk$ID_yorder,IDxwalk$ID_atomorder)]
## get expand_x/y
expand_x<-IDxwalk$ID_xorder[order(IDxwalk$ID_xorder)]
expand_y<-IDxwalk$ID_yorder[order(IDxwalk$ID_yorder)]
## get x/y_latentind
IDxwalk<-IDxwalk[order(IDxwalk$ID_xorder,IDxwalk$ID_atomorder),]
x_nonatoms<-IDxwalk$ID_xorder[which(duplicated(IDxwalk$ID_xorder)==T)]
x_latentind<-matrix(0,length(x_nonatoms),2)
for (i in 1:length(x_nonatoms)){
x_latentind[i,]<-c(min(which(IDxwalk$ID_xorder==x_nonatoms[i])),max(which(IDxwalk$ID_xorder==x_nonatoms[i])))-J_x
}
IDxwalk<-IDxwalk[order(IDxwalk$ID_yorder,IDxwalk$ID_atomorder),]
y_nonatoms<-IDxwalk$ID_yorder[which(duplicated(IDxwalk$ID_yorder)==T)]
y_latentind<-matrix(0,length(y_nonatoms),2)
for (i in 1:length(y_nonatoms)){
y_latentind[i,]<-c(min(which(IDxwalk$ID_yorder==y_nonatoms[i])),max(which(IDxwalk$ID_yorder==y_nonatoms[i])))-J_y
}
## get x_reorder
IDxwalk<-IDxwalk[order(IDxwalk$ID_xorder,IDxwalk$ID_atomorder),]
IDxwalk$xro<-1:nrow(IDxwalk)
IDxwalk<-IDxwalk[order(IDxwalk$ID_atomorder),]
x_reorder<-IDxwalk$xro
## make spatial adjacency matrices for X and Y grids based on new orderings
neighbors_x <- poly2nb(as(gridx_xorder, "Spatial"), queen = TRUE)
W_x <- nb2mat(neighbors_x, style = "B", zero.policy = TRUE)
neighbors_y <- poly2nb(as(gridy_yorder, "Spatial"), queen = TRUE)
W_y <- nb2mat(neighbors_y, style = "B", zero.policy = TRUE)
## inputs to nimble
constants<-list(p=2,
D=nrow(atoms),
S_x= S_x,
S_y= S_y,
J_x= J_x,
J_y= J_y,
x_to_atom=x_to_atom,
y_to_atom=y_to_atom,
xlatent_ind=x_latentind,
ylatent_ind=y_latentind,
expand_x=expand_x,
expand_y=expand_y,
x_reorder=x_reorder,
num_x = as.carAdjacency(W_x)$num,
weights_x = as.carAdjacency(W_x)$weights,
adj_x = as.carAdjacency(W_x)$adj,
num_y = as.carAdjacency(W_y)$num,
weights_y = as.carAdjacency(W_y)$weights,
adj_y = as.carAdjacency(W_y)$adj)
data<-list(
x=gridx_xorder$x,
y=gridy_yorder$y,
pred=cbind(1,pred),
offs_x=rep(0,nrow(atoms)),
offs_y=rep(0,nrow(atoms))
)
inits<-list(
beta_x=rep(0,2),
beta_y=rep(0,3),
tau_x = 1, tau_y = 1,
phi_x=rep(0,S_x),
phi_y=rep(0,S_y)
)
######################
## run nimble model ##
######################
source('nimble_abrm.R')
## create nimble model ##
Rmodel <- nimbleModel(abrm, constants, data, inits,calculate=FALSE)
## compile nimble model ##
compmod <- compileNimble(Rmodel)
## configure mcmc ##
mcmcConf <- configureMCMC(compmod, enableWAIC = F,
monitors=c('beta_x',
'beta_y'),thin=10,
useConjugacy=FALSE)
## build mcmc ##
Rmcmc <- buildMCMC(mcmcConf)
## compile mcmc ##
Cmcmc <- compileNimble(Rmcmc, project = compmod)
## run mcmc ##
mcmc.out <- runMCMC(Cmcmc, niter=10000,nburnin=5000,nchains=1,summary=T)
save(mcmc.out,file='model_output.RData')
